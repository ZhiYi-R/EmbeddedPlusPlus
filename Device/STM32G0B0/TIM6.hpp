/* Auto-generated file. Do not edit manually. */

#ifndef EMBEDDED_PP_STM32G0B0_TIM6_HPP
#define EMBEDDED_PP_STM32G0B0_TIM6_HPP

#include <cstdint>
#include "Core/Common.hpp"
#include "Core/BitField.hpp"
#include "Core/Register.hpp"

/** @brief Basic timers */
namespace STM32G0B0::TIM6 {

    /** @brief control register 1 */
    using CR1 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x0, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Counter enable Note: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware. CEN is cleared automatically in one-pulse mode, when an update event occurs. */
    using CR1_CEN = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Counter disabled (value: 0)
     *          - B_0x1: Counter enabled (value: 1)
     */
        /** @brief Counter disabled */
    constexpr std::uint32_t CR1_CEN_B_0x0 = 0;
        /** @brief Counter enabled */
    constexpr std::uint32_t CR1_CEN_B_0x1 = 1;

    /** @brief Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values. */
    using CR1_UDIS = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: UEV enabled. The Update (UEV) event is generated by one of the following events: (value: 0)
     *          - B_0x1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. (value: 1)
     */
        /** @brief UEV enabled. The Update (UEV) event is generated by one of the following events: */
    constexpr std::uint32_t CR1_UDIS_B_0x0 = 0;
        /** @brief UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. */
    constexpr std::uint32_t CR1_UDIS_B_0x1 = 1;

    /** @brief Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller */
    using CR1_URS = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 2, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Any of the following events generates an update interrupt or DMA request if enabled. These events can be: (value: 0)
     *          - B_0x1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled. (value: 1)
     */
        /** @brief Any of the following events generates an update interrupt or DMA request if enabled. These events can be: */
    constexpr std::uint32_t CR1_URS_B_0x0 = 0;
        /** @brief Only counter overflow/underflow generates an update interrupt or DMA request if enabled. */
    constexpr std::uint32_t CR1_URS_B_0x1 = 1;

    /** @brief One-pulse mode */
    using CR1_OPM = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 3, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Counter is not stopped at update event (value: 0)
     *          - B_0x1: Counter stops counting at the next update event (clearing the CEN bit). (value: 1)
     */
        /** @brief Counter is not stopped at update event */
    constexpr std::uint32_t CR1_OPM_B_0x0 = 0;
        /** @brief Counter stops counting at the next update event (clearing the CEN bit). */
    constexpr std::uint32_t CR1_OPM_B_0x1 = 1;

    /** @brief Auto-reload preload enable */
    using CR1_ARPE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 7, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: TIMx_ARR register is not buffered. (value: 0)
     *          - B_0x1: TIMx_ARR register is buffered. (value: 1)
     */
        /** @brief TIMx_ARR register is not buffered. */
    constexpr std::uint32_t CR1_ARPE_B_0x0 = 0;
        /** @brief TIMx_ARR register is buffered. */
    constexpr std::uint32_t CR1_ARPE_B_0x1 = 1;

    /** @brief UIF status bit remapping */
    using CR1_UIFREMAP = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 11, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: No remapping. UIF status bit is not copied to TIMx_CNT register bit 31. (value: 0)
     *          - B_0x1: Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. (value: 1)
     */
        /** @brief No remapping. UIF status bit is not copied to TIMx_CNT register bit 31. */
    constexpr std::uint32_t CR1_UIFREMAP_B_0x0 = 0;
        /** @brief Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. */
    constexpr std::uint32_t CR1_UIFREMAP_B_0x1 = 1;

    /** @brief control register 2 */
    using CR2 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Master mode selection These bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: When the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR register). Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer. */
    using CR2_MMS = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 4, 3, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset. (value: 0)
     *          - B_0x1: Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. (value: 1)
     *          - B_0x2: Update - The update event is selected as a trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer. (value: 2)
     */
        /** @brief Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If reset is generated by the trigger input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset. */
    constexpr std::uint32_t CR2_MMS_B_0x0 = 0;
        /** @brief Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between CEN control bit and the trigger input when configured in gated mode. */
    constexpr std::uint32_t CR2_MMS_B_0x1 = 1;
        /** @brief Update - The update event is selected as a trigger output (TRGO). For instance a master timer can then be used as a prescaler for a slave timer. */
    constexpr std::uint32_t CR2_MMS_B_0x2 = 2;

    /** @brief DMA/Interrupt enable register */
    using DIER = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0xC, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Update interrupt enable */
    using DIER_UIE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Update interrupt disabled. (value: 0)
     *          - B_0x1: Update interrupt enabled. (value: 1)
     */
        /** @brief Update interrupt disabled. */
    constexpr std::uint32_t DIER_UIE_B_0x0 = 0;
        /** @brief Update interrupt enabled. */
    constexpr std::uint32_t DIER_UIE_B_0x1 = 1;

    /** @brief Update DMA request enable */
    using DIER_UDE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 8, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Update DMA request disabled. (value: 0)
     *          - B_0x1: Update DMA request enabled. (value: 1)
     */
        /** @brief Update DMA request disabled. */
    constexpr std::uint32_t DIER_UDE_B_0x0 = 0;
        /** @brief Update DMA request enabled. */
    constexpr std::uint32_t DIER_UDE_B_0x1 = 1;

    /** @brief status register */
    using SR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Update interrupt flag */
    using SR_UIF = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: No update occurred. (value: 0)
     *          - B_0x1: Update interrupt pending. This bit is set by hardware when the registers are updated: (value: 1)
     */
        /** @brief No update occurred. */
    constexpr std::uint32_t SR_UIF_B_0x0 = 0;
        /** @brief Update interrupt pending. This bit is set by hardware when the registers are updated: */
    constexpr std::uint32_t SR_UIF_B_0x1 = 1;

    /** @brief event generation register */
    using EGR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x14, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Update generation This bit can be set by software, it is automatically cleared by hardware. */
    using EGR_UG = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: No action. (value: 0)
     *          - B_0x1: Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected). (value: 1)
     */
        /** @brief No action. */
    constexpr std::uint32_t EGR_UG_B_0x0 = 0;
        /** @brief Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected). */
    constexpr std::uint32_t EGR_UG_B_0x1 = 1;

    /** @brief counter */
    using CNT = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x24, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Counter value */
    using CNT_CNT = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief UIF Copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0. */
    using CNT_UIFCPY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief prescaler */
    using PSC = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x28, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Prescaler value */
    using PSC_PSC = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief auto-reload register */
    using ARR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x2C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Prescaler value */
    using ARR_ARR = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
}

#endif
