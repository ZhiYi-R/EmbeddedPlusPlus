/* Auto-generated file. Do not edit manually. */

#ifndef EMBEDDED_PP_STM32H562_SEC_TIM7_HPP
#define EMBEDDED_PP_STM32H562_SEC_TIM7_HPP

#include <cstdint>
#include "Core/Common.hpp"
#include "Core/BitField.hpp"
#include "Core/Register.hpp"

/** @brief Basic timers */
namespace STM32H562::SEC_TIM7 {

    /** @brief TIM7 control register 1 */
    using TIM7_CR1 = ::EmbeddedPP::LowLevel::Register<std::uint16_t, 0x0, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Counter enable CEN is cleared automatically in one-pulse mode, when an update event occurs. */
    using TIM7_CR1_CEN = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Counter disabled (value: 0)
     *          - B_0x1: Counter enabled (value: 1)
     */
        /** @brief Counter disabled */
    constexpr std::uint16_t TIM7_CR1_CEN_B_0x0 = 0;
        /** @brief Counter enabled */
    constexpr std::uint16_t TIM7_CR1_CEN_B_0x1 = 1;

    /** @brief Update disable This bit is set and cleared by software to enable/disable UEV event generation. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller Buffered registers are then loaded with their preload values. */
    using TIM7_CR1_UDIS = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: UEV enabled. The Update (UEV) event is generated by one of the following events: (value: 0)
     *          - B_0x1: UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. (value: 1)
     */
        /** @brief UEV enabled. The Update (UEV) event is generated by one of the following events: */
    constexpr std::uint16_t TIM7_CR1_UDIS_B_0x0 = 0;
        /** @brief UEV disabled. The Update event is not generated, shadow registers keep their value (ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if a hardware reset is received from the slave mode controller. */
    constexpr std::uint16_t TIM7_CR1_UDIS_B_0x1 = 1;

    /** @brief Update request source This bit is set and cleared by software to select the UEV event sources. Counter overflow/underflow Setting the UG bit Update generation through the slave mode controller */
    using TIM7_CR1_URS = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 2, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Any of the following events generates an update interrupt or DMA request if enabled. These events can be: (value: 0)
     *          - B_0x1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled. (value: 1)
     */
        /** @brief Any of the following events generates an update interrupt or DMA request if enabled. These events can be: */
    constexpr std::uint16_t TIM7_CR1_URS_B_0x0 = 0;
        /** @brief Only counter overflow/underflow generates an update interrupt or DMA request if enabled. */
    constexpr std::uint16_t TIM7_CR1_URS_B_0x1 = 1;

    /** @brief One-pulse mode */
    using TIM7_CR1_OPM = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 3, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Counter is not stopped at update event (value: 0)
     *          - B_0x1: Counter stops counting at the next update event (clearing the CEN bit). (value: 1)
     */
        /** @brief Counter is not stopped at update event */
    constexpr std::uint16_t TIM7_CR1_OPM_B_0x0 = 0;
        /** @brief Counter stops counting at the next update event (clearing the CEN bit). */
    constexpr std::uint16_t TIM7_CR1_OPM_B_0x1 = 1;

    /** @brief Auto-reload preload enable */
    using TIM7_CR1_ARPE = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 7, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: TIMx_ARR register is not buffered. (value: 0)
     *          - B_0x1: TIMx_ARR register is buffered. (value: 1)
     */
        /** @brief TIMx_ARR register is not buffered. */
    constexpr std::uint16_t TIM7_CR1_ARPE_B_0x0 = 0;
        /** @brief TIMx_ARR register is buffered. */
    constexpr std::uint16_t TIM7_CR1_ARPE_B_0x1 = 1;

    /** @brief UIF status bit remapping */
    using TIM7_CR1_UIFREMAP = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 11, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: No remapping. UIF status bit is not copied to TIMx_CNT register bit 31. (value: 0)
     *          - B_0x1: Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. (value: 1)
     */
        /** @brief No remapping. UIF status bit is not copied to TIMx_CNT register bit 31. */
    constexpr std::uint16_t TIM7_CR1_UIFREMAP_B_0x0 = 0;
        /** @brief Remapping enabled. UIF status bit is copied to TIMx_CNT register bit 31. */
    constexpr std::uint16_t TIM7_CR1_UIFREMAP_B_0x1 = 1;

    /** @brief Dithering enable Note: The DITHEN bit can only be modified when CEN bit is reset. */
    using TIM7_CR1_DITHEN = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 12, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Dithering disabled (value: 0)
     *          - B_0x1: Dithering enabled (value: 1)
     */
        /** @brief Dithering disabled */
    constexpr std::uint16_t TIM7_CR1_DITHEN_B_0x0 = 0;
        /** @brief Dithering enabled */
    constexpr std::uint16_t TIM7_CR1_DITHEN_B_0x1 = 1;

    /** @brief TIM7 control register 2 */
    using TIM7_CR2 = ::EmbeddedPP::LowLevel::Register<std::uint16_t, 0x4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Master mode selection These bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows: Note: The clock of the slave timer or he peripheral receiving the tim_trgo must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer. */
    using TIM7_CR2_MMS = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 4, 3, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Reset the UG bit from the TIMx_EGR register is used as a trigger output (tim_trgo). (value: 0)
     *          - B_0x1: Enable the Counter enable signal, tim_cnt_en, is used as a trigger output (tim_trgo). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated when the CEN control bit is written. (value: 1)
     *          - B_0x2: Update The update event is selected as a trigger output (tim_trgo). For instance a master timer can then be used as a prescaler for a slave timer. (value: 2)
     */
        /** @brief Reset the UG bit from the TIMx_EGR register is used as a trigger output (tim_trgo). */
    constexpr std::uint16_t TIM7_CR2_MMS_B_0x0 = 0;
        /** @brief Enable the Counter enable signal, tim_cnt_en, is used as a trigger output (tim_trgo). It is useful to start several timers at the same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated when the CEN control bit is written. */
    constexpr std::uint16_t TIM7_CR2_MMS_B_0x1 = 1;
        /** @brief Update The update event is selected as a trigger output (tim_trgo). For instance a master timer can then be used as a prescaler for a slave timer. */
    constexpr std::uint16_t TIM7_CR2_MMS_B_0x2 = 2;

    /** @brief TIM7 DMA/Interrupt enable register */
    using TIM7_DIER = ::EmbeddedPP::LowLevel::Register<std::uint16_t, 0xC, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Update interrupt enable */
    using TIM7_DIER_UIE = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Update interrupt disabled. (value: 0)
     *          - B_0x1: Update interrupt enabled. (value: 1)
     */
        /** @brief Update interrupt disabled. */
    constexpr std::uint16_t TIM7_DIER_UIE_B_0x0 = 0;
        /** @brief Update interrupt enabled. */
    constexpr std::uint16_t TIM7_DIER_UIE_B_0x1 = 1;

    /** @brief Update DMA request enable */
    using TIM7_DIER_UDE = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 8, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Update DMA request disabled. (value: 0)
     *          - B_0x1: Update DMA request enabled. (value: 1)
     */
        /** @brief Update DMA request disabled. */
    constexpr std::uint16_t TIM7_DIER_UDE_B_0x0 = 0;
        /** @brief Update DMA request enabled. */
    constexpr std::uint16_t TIM7_DIER_UDE_B_0x1 = 1;

    /** @brief TIM7 status register */
    using TIM7_SR = ::EmbeddedPP::LowLevel::Register<std::uint16_t, 0x10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Update interrupt flag This bit is set by hardware on an update event. It is cleared by software. On counter overflow if UDIS = 0 in the TIMx_CR1 register. When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS = 0 and UDIS = 0 in the TIMx_CR1 register. */
    using TIM7_SR_UIF = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: No update occurred. (value: 0)
     *          - B_0x1: Update interrupt pending. This bit is set by hardware when the registers are updated: (value: 1)
     */
        /** @brief No update occurred. */
    constexpr std::uint16_t TIM7_SR_UIF_B_0x0 = 0;
        /** @brief Update interrupt pending. This bit is set by hardware when the registers are updated: */
    constexpr std::uint16_t TIM7_SR_UIF_B_0x1 = 1;

    /** @brief TIM7 event generation register */
    using TIM7_EGR = ::EmbeddedPP::LowLevel::Register<std::uint16_t, 0x14, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Update generation This bit can be set by software, it is automatically cleared by hardware. */
    using TIM7_EGR_UG = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: No action. (value: 0)
     *          - B_0x1: Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected). (value: 1)
     */
        /** @brief No action. */
    constexpr std::uint16_t TIM7_EGR_UG_B_0x0 = 0;
        /** @brief Re-initializes the timer counter and generates an update of the registers. Note that the prescaler counter is cleared too (but the prescaler ratio is not affected). */
    constexpr std::uint16_t TIM7_EGR_UG_B_0x1 = 1;

    /** @brief TIM7 counter */
    using TIM7_CNT = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x24, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Counter value Non-dithering mode (DITHEN = 0) The register holds the counter value. Dithering mode (DITHEN = 1) The register only holds the non-dithered part in CNT[15:0]. The fractional part is not available. */
    using TIM7_CNT_CNT = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief UIF copy This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0. */
    using TIM7_CNT_UIFCPY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief TIM7 prescaler */
    using TIM7_PSC = ::EmbeddedPP::LowLevel::Register<std::uint16_t, 0x28, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Prescaler value The counter clock frequency ftim_cnt_ck is equal to ftim_psc_ck / (PSC[15:0] + 1). PSC contains the value to be loaded into the active prescaler register at each update event. (including when the counter is cleared through UG bit of TIMx_EGR register. */
    using TIM7_PSC_PSC = ::EmbeddedPP::LowLevel::BitField<std::uint16_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief TIM7 auto-reload register */
    using TIM7_ARR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x2C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Auto-reload value ARR is the value to be loaded into the actual auto-reload register. Refer to for more details about ARR update and behavior. The counter is blocked while the auto-reload value is null. Non-dithering mode (DITHEN = 0) The register holds the auto-reload value in ARR[15:0]. The ARR[19:16] bits are reserved. Dithering mode (DITHEN = 1) The register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part. */
    using TIM7_ARR_ARR = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 20, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
}

#endif
