/* Auto-generated file. Do not edit manually. */

#ifndef EMBEDDED_PP_STM32H573_AES_HPP
#define EMBEDDED_PP_STM32H573_AES_HPP

#include <cstdint>
#include "Core/Common.hpp"
#include "Core/BitField.hpp"
#include "Core/Register.hpp"

/** @brief Advanced encryption standard hardware accelerator */
namespace STM32H573::AES {

    /** @brief AES control register */
    using AES_CR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x0, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES enable This bit enables/disables the AES peripheral: At any moment, clearing then setting the bit re-initializes the AES peripheral. This bit is automatically cleared by hardware upon the completion of the key preparation (Mode 2) and upon the completion of GCM/GMAC/CCM initial phase. The bit cannot be set as long as KEYVALID = 0. Note: With KMOD[1:0] other than 00, use the IPRST bit rather than the bit EN. */
    using AES_CR_EN = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Disable (value: 0)
     *          - B_0x1: Enable (value: 1)
     */
        /** @brief Disable */
    constexpr std::uint32_t AES_CR_EN_B_0x0 = 0;
        /** @brief Enable */
    constexpr std::uint32_t AES_CR_EN_B_0x1 = 1;

    /** @brief Data type selection This bitfield defines the format of data written in the AES_DINR register or read from the AES_DOUTR register, through selecting the mode of data swapping: For more details, refer to . Attempts to write the bitfield are ignored when the BUSY flag of AES_SR register is set, as well as when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access. */
    using AES_CR_DATATYPE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: None (value: 0)
     *          - B_0x1: Half-word (16-bit) (value: 1)
     *          - B_0x2: Byte (8-bit) (value: 2)
     *          - B_0x3: Bit (value: 3)
     */
        /** @brief None */
    constexpr std::uint32_t AES_CR_DATATYPE_B_0x0 = 0;
        /** @brief Half-word (16-bit) */
    constexpr std::uint32_t AES_CR_DATATYPE_B_0x1 = 1;
        /** @brief Byte (8-bit) */
    constexpr std::uint32_t AES_CR_DATATYPE_B_0x2 = 2;
        /** @brief Bit */
    constexpr std::uint32_t AES_CR_DATATYPE_B_0x3 = 3;

    /** @brief AES operating mode This bitfield selects the AES operating mode: Attempts to write the bitfield are ignored when the BUSY flag of AES_SR register is set, as well as when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access. */
    using AES_CR_MODE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 3, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Mode 1: encryption (value: 0)
     *          - B_0x1: Mode 2: key derivation (or key preparation for ECB/CBC decryption) (value: 1)
     *          - B_0x2: Mode 3: decryption (value: 2)
     */
        /** @brief Mode 1: encryption */
    constexpr std::uint32_t AES_CR_MODE_B_0x0 = 0;
        /** @brief Mode 2: key derivation (or key preparation for ECB/CBC decryption) */
    constexpr std::uint32_t AES_CR_MODE_B_0x1 = 1;
        /** @brief Mode 3: decryption */
    constexpr std::uint32_t AES_CR_MODE_B_0x2 = 2;

    /** @brief Chaining mode selection This bitfield selects the AES chaining mode: others: Reserved Attempts to write the bitfield are ignored when the BUSY flag of AES_SR register is set, as well as when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access. */
    using AES_CR_CHMOD1 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 5, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Electronic codebook (ECB) (value: 0)
     *          - B_0x1: Cipher-block chaining (CBC) (value: 1)
     *          - B_0x2: Counter mode (CTR) (value: 2)
     *          - B_0x3: Galois counter mode (GCM) and Galois message authentication code (GMAC) (value: 3)
     */
        /** @brief Electronic codebook (ECB) */
    constexpr std::uint32_t AES_CR_CHMOD1_B_0x0 = 0;
        /** @brief Cipher-block chaining (CBC) */
    constexpr std::uint32_t AES_CR_CHMOD1_B_0x1 = 1;
        /** @brief Counter mode (CTR) */
    constexpr std::uint32_t AES_CR_CHMOD1_B_0x2 = 2;
        /** @brief Galois counter mode (GCM) and Galois message authentication code (GMAC) */
    constexpr std::uint32_t AES_CR_CHMOD1_B_0x3 = 3;

    /** @brief DMA input enable This bit enables/disables data transferring with DMA, in the input phase: When the bit is set, DMA requests are automatically generated by AES during the input data phase. This feature is only effective when Mode 1 or Mode 3 is selected through the MODE[1:0] bitfield. It is not effective for Mode 2 (key derivation). */
    using AES_CR_DMAINEN = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 11, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Disable (value: 0)
     *          - B_0x1: Enable (value: 1)
     */
        /** @brief Disable */
    constexpr std::uint32_t AES_CR_DMAINEN_B_0x0 = 0;
        /** @brief Enable */
    constexpr std::uint32_t AES_CR_DMAINEN_B_0x1 = 1;

    /** @brief DMA output enable This bit enables/disables data transferring with DMA, in the output phase: When the bit is set, DMA requests are automatically generated by AES during the output data phase. This feature is only effective when Mode 1 or Mode 3 is selected through the MODE[1:0] bitfield. It is not effective for Mode 2 (key derivation). */
    using AES_CR_DMAOUTEN = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 12, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Disable (value: 0)
     *          - B_0x1: Enable (value: 1)
     */
        /** @brief Disable */
    constexpr std::uint32_t AES_CR_DMAOUTEN_B_0x0 = 0;
        /** @brief Enable */
    constexpr std::uint32_t AES_CR_DMAOUTEN_B_0x1 = 1;

    /** @brief GCM or CCM phase selection This bitfield selects the phase of GCM, GMAC or CCM algorithm: The bitfield has no effect if other than GCM, GMAC or CCM algorithms are selected (through the ALGOMODE bitfield). */
    using AES_CR_GCMPH = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 13, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Init phase (value: 0)
     *          - B_0x1: Header phase (value: 1)
     *          - B_0x2: Payload phase (value: 2)
     *          - B_0x3: Final phase (value: 3)
     */
        /** @brief Init phase */
    constexpr std::uint32_t AES_CR_GCMPH_B_0x0 = 0;
        /** @brief Header phase */
    constexpr std::uint32_t AES_CR_GCMPH_B_0x1 = 1;
        /** @brief Payload phase */
    constexpr std::uint32_t AES_CR_GCMPH_B_0x2 = 2;
        /** @brief Final phase */
    constexpr std::uint32_t AES_CR_GCMPH_B_0x3 = 3;

    /** @brief Chaining mode selection This bitfield selects the AES chaining mode: others: Reserved Attempts to write the bitfield are ignored when the BUSY flag of AES_SR register is set, as well as when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access. */
    using AES_CR_CHMOD2 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Electronic codebook (ECB) (value: 0)
     *          - B_0x1: Cipher-block chaining (CBC) (value: 1)
     */
        /** @brief Electronic codebook (ECB) */
    constexpr std::uint32_t AES_CR_CHMOD2_B_0x0 = 0;
        /** @brief Cipher-block chaining (CBC) */
    constexpr std::uint32_t AES_CR_CHMOD2_B_0x1 = 1;

    /** @brief Key size selection This bitfield defines the length of the key used in the AES cryptographic core, in bits: Attempts to write the bit are ignored when the BUSY flag of AES_SR register is set, as well as when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access. */
    using AES_CR_KEYSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 18, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: 128 (value: 0)
     *          - B_0x1: 256 (value: 1)
     */
        /** @brief 128 */
    constexpr std::uint32_t AES_CR_KEYSIZE_B_0x0 = 0;
        /** @brief 256 */
    constexpr std::uint32_t AES_CR_KEYSIZE_B_0x1 = 1;

    /** @brief Number of padding bytes in last block The bitfield sets the number of padding bytes in last block of payload: ... */
    using AES_CR_NPBLB = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 20, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: All bytes are valid (no padding) (value: 0)
     *          - B_0x1: Padding for one least-significant byte of last block (value: 1)
     *          - B_0xF: Padding for 15 least-significant bytes of last block (value: 15)
     */
        /** @brief All bytes are valid (no padding) */
    constexpr std::uint32_t AES_CR_NPBLB_B_0x0 = 0;
        /** @brief Padding for one least-significant byte of last block */
    constexpr std::uint32_t AES_CR_NPBLB_B_0x1 = 1;
        /** @brief Padding for 15 least-significant bytes of last block */
    constexpr std::uint32_t AES_CR_NPBLB_B_0xF = 15;

    /** @brief Key mode selection The bitfield defines how the AES key can be used by the application: Others: Reserved With normal key selection, the key registers are freely usable, no specific usage or protection applies to AES_DIN and AES_DOUT registers. With selection of shared key from SAES co-processor, the AES peripheral automatically loads its key registers with the data stored in the key registers of the SAES peripheral. The key value is available in key registers when BUSY bit is cleared and KEYVALID is set in the AES_SR register. Key error flag KEIF is set otherwise in the AES_ISR register. The bitfield must be set only when KEYSIZE is correct, and when a shared key decryption sequence has been successfully completed in SAES co-processor. N/AAttempts to write the bitfield are ignored when the BUSY flag of AES_SR register is set, as well as when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access. */
    using AES_CR_KMOD = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 24, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Normal key (value: 0)
     *          - B_0x2: Shared key from SAES co-processor (value: 2)
     */
        /** @brief Normal key */
    constexpr std::uint32_t AES_CR_KMOD_B_0x0 = 0;
        /** @brief Shared key from SAES co-processor */
    constexpr std::uint32_t AES_CR_KMOD_B_0x2 = 2;

    /** @brief AES peripheral software reset Setting the bit resets the AES peripheral, putting all registers to their default values, except the IPRST bit itself. Hence, any key-relative data is lost. For this reason, it is recommended to set the bit before handing over the AES to a less secure application. The bit must be low while writing any configuration registers. */
    using AES_CR_IPRST = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES status register */
    using AES_SR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Computation completed flag This bit mirrors the CCF bit of the AES_ISR register. */
    using AES_SR_CCF = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Read error flag This flag indicates the detection of an unexpected read operation from the AES_DOUTR register (during computation or data input phase): The flag is set by hardware. It is cleared by software upon setting the RWEIF bit of the AES_ICR register. Upon the flag setting, an interrupt is generated if enabled through the RWEIE bit of the AES_ICR register. The flag setting has no impact on the AES operation. Unexpected read returns zero. */
    using AES_SR_RDERR = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Not detected (value: 0)
     *          - B_0x1: Detected (value: 1)
     */
        /** @brief Not detected */
    constexpr std::uint32_t AES_SR_RDERR_B_0x0 = 0;
        /** @brief Detected */
    constexpr std::uint32_t AES_SR_RDERR_B_0x1 = 1;

    /** @brief Write error This flag indicates the detection of an unexpected write operation to the AES_DINR register (during computation or data output phase): The flag is set by hardware. It is cleared by software upon setting the RWEIF bit of the AES_ICR register. Upon the flag setting, an interrupt is generated if enabled through the RWEIE bit of the AES_ICR register. The flag setting has no impact on the AES operation. Unexpected write is ignored. */
    using AES_SR_WRERR = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 2, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Not detected (value: 0)
     *          - B_0x1: Detected (value: 1)
     */
        /** @brief Not detected */
    constexpr std::uint32_t AES_SR_WRERR_B_0x0 = 0;
        /** @brief Detected */
    constexpr std::uint32_t AES_SR_WRERR_B_0x1 = 1;

    /** @brief Busy This flag indicates whether AES is idle or busy during GCM payload encryption phase: When the flag indicates 'idle', the current GCM encryption processing may be suspended to process a higher-priority message. In other chaining modes, or in GCM phases other than payload encryption, the flag must be ignored for the suspend process. The flag is set when transferring a shared key from SAES peripheral. */
    using AES_SR_BUSY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 3, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Idle (value: 0)
     *          - B_0x1: Busy (value: 1)
     */
        /** @brief Idle */
    constexpr std::uint32_t AES_SR_BUSY_B_0x0 = 0;
        /** @brief Busy */
    constexpr std::uint32_t AES_SR_BUSY_B_0x1 = 1;

    /** @brief Key Valid flag This bit is set by hardware when the amount of key information defined by KEYSIZE in AES_CR has been loaded in AES_KEYx key registers. In normal mode when KEYSEL equals to zero, the application must write the key registers in the correct sequence, otherwise the KEIF flag of the AES_ISR register is set and KEYVALID stays at zero. When KEYSEL is different from zero the BUSY flag is automatically set by AES. When key is loaded successfully, the BUSY flag is cleared and KEYVALID set. Upon an error, the KEIF flag of the AES_ISR register is set, the BUSY flag cleared and KEYVALID kept at zero. When the KEIF flag is set, the application must clear it through the AES_ICR register, otherwise KEYVALID cannot be set. See the KEIF bit description for more details. For more information on key loading please refer to . */
    using AES_SR_KEYVALID = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 7, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: No valid key information is available in key registers. EN bit in AES_CR cannot be set. (value: 0)
     *          - B_0x1: Valid key information, defined by KEYSIZE in AES_CR, is loaded in key registers. (value: 1)
     */
        /** @brief No valid key information is available in key registers. EN bit in AES_CR cannot be set. */
    constexpr std::uint32_t AES_SR_KEYVALID_B_0x0 = 0;
        /** @brief Valid key information, defined by KEYSIZE in AES_CR, is loaded in key registers. */
    constexpr std::uint32_t AES_SR_KEYVALID_B_0x1 = 1;

    /** @brief AES data input register */
    using AES_DINR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x8, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Input data word A four-fold sequential write to this bitfield during the input phase results in writing a complete 128-bit block of input data to the AES peripheral. From the first to the fourth write, the corresponding data weights are [127:96], [95:64], [63:32], and [31:0]. Upon each write, the data from the 32-bit input buffer are handled by the data swap block according to the DATATYPE[1:0] bitfield, then written into the AES core 128-bit input buffer. The data signification of the input data block depends on the AES operating mode: - Mode 1 (encryption): plaintext - Mode 2 (key derivation): the bitfield is not used (AES_KEYRx registers used for input) - Mode 3 (decryption): ciphertext The data swap operation is described in page 1149. */
    using AES_DINR_DIN = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES data output register */
    using AES_DOUTR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0xC, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Output data word This read-only bitfield fetches a 32-bit output buffer. A four-fold sequential read of this bitfield, upon the computation completion (CCF set), virtually reads a complete 128-bit block of output data from the AES peripheral. Before reaching the output buffer, the data produced by the AES core are handled by the data swap block according to the DATATYPE[1:0] bitfield. Data weights from the first to the fourth read operation are: [127:96], [95:64], [63:32], and [31:0]. The data signification of the output data block depends on the AES operating mode: - Mode 1 (encryption): ciphertext - Mode 2 (key derivation): the bitfield is not used - Mode 3 (decryption): plaintext The data swap operation is described in page 1149. */
    using AES_DOUTR_DOUT = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES key register 0 */
    using AES_KEYR0 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Cryptographic key, bits [31:0] This write-only bitfield contains the bits [31:0] of the AES encryption or decryption key, depending on the operating mode: - In Mode 1 (encryption), Mode 2 (key derivation): the value to write into the bitfield is the encryption key. - In Mode 3 (decryption): the value to write into the bitfield is the encryption key to be derived before being used for decryption. The AES_KEYRx registers may be written only when KEYSIZE value is correct and when the AES peripheral is disabled (EN bit of the AES_CR register cleared). A special writing sequence is also required, as described in KEYVALID bit of the AES_SR register. Note that, if KMOD[1:0] = 10 (shared key), the key is directly loaded from SAES peripheral to AES_KEYRx registers (hence writes to key register is ignored and KEIF is set). Refer to for more details. */
    using AES_KEYR0_KEY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES key register 1 */
    using AES_KEYR1 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x14, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Cryptographic key, bits [63:32] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield. */
    using AES_KEYR1_KEY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES key register 2 */
    using AES_KEYR2 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x18, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Cryptographic key, bits [95:64] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield. */
    using AES_KEYR2_KEY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES key register 3 */
    using AES_KEYR3 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x1C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Cryptographic key, bits [127:96] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield. */
    using AES_KEYR3_KEY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES initialization vector register 0 */
    using AES_IVR0 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x20, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Initialization vector input, bits [31:0] Refer to for description of the IVI[127:0] bitfield. The initialization vector is only used in chaining modes other than ECB. The AES_IVRx registers may be written only when the AES peripheral is disabled */
    using AES_IVR0_IVI = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES initialization vector register 1 */
    using AES_IVR1 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x24, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Initialization vector input, bits [63:32] Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield. */
    using AES_IVR1_IVI = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES initialization vector register 2 */
    using AES_IVR2 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x28, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Initialization vector input, bits [95:64] Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield. */
    using AES_IVR2_IVI = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES initialization vector register 3 */
    using AES_IVR3 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x2C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Initialization vector input, bits [127:96] Refer to the AES_IVR0 register for description of the IVI[128:0] bitfield. */
    using AES_IVR3_IVI = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES key register 4 */
    using AES_KEYR4 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x30, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Cryptographic key, bits [159:128] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield. */
    using AES_KEYR4_KEY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES key register 5 */
    using AES_KEYR5 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x34, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Cryptographic key, bits [191:160] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield. */
    using AES_KEYR5_KEY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES key register 6 */
    using AES_KEYR6 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x38, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Cryptographic key, bits [223:192] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield. */
    using AES_KEYR6_KEY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES key register 7 */
    using AES_KEYR7 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x3C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Cryptographic key, bits [255:224] Refer to the AES_KEYR0 register for description of the KEY[255:0] bitfield. */
    using AES_KEYR7_KEY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend registers */
    using AES_SUSP0R = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x40, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend Upon suspend operation, this bitfield of the corresponding AES_SUSPxR register takes the value of one of internal AES registers. */
    using AES_SUSP0R_SUSP = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend registers */
    using AES_SUSP1R = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x44, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend Upon suspend operation, this bitfield of the corresponding AES_SUSPxR register takes the value of one of internal AES registers. */
    using AES_SUSP1R_SUSP = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend registers */
    using AES_SUSP2R = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x48, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend Upon suspend operation, this bitfield of the corresponding AES_SUSPxR register takes the value of one of internal AES registers. */
    using AES_SUSP2R_SUSP = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend registers */
    using AES_SUSP3R = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x4C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend Upon suspend operation, this bitfield of the corresponding AES_SUSPxR register takes the value of one of internal AES registers. */
    using AES_SUSP3R_SUSP = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend registers */
    using AES_SUSP4R = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x50, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend Upon suspend operation, this bitfield of the corresponding AES_SUSPxR register takes the value of one of internal AES registers. */
    using AES_SUSP4R_SUSP = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend registers */
    using AES_SUSP5R = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x54, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend Upon suspend operation, this bitfield of the corresponding AES_SUSPxR register takes the value of one of internal AES registers. */
    using AES_SUSP5R_SUSP = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend registers */
    using AES_SUSP6R = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x58, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend Upon suspend operation, this bitfield of the corresponding AES_SUSPxR register takes the value of one of internal AES registers. */
    using AES_SUSP6R_SUSP = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend registers */
    using AES_SUSP7R = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x5C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES suspend Upon suspend operation, this bitfield of the corresponding AES_SUSPxR register takes the value of one of internal AES registers. */
    using AES_SUSP7R_SUSP = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 32, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief AES interrupt enable register */
    using AES_IER = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x300, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Computation complete flag interrupt enable This bit enables or disables (masks) the AES interrupt generation when CCF (computation complete flag) is set. */
    using AES_IER_CCFIE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Disabled (masked) (value: 0)
     *          - B_0x1: Enabled (not masked) (value: 1)
     */
        /** @brief Disabled (masked) */
    constexpr std::uint32_t AES_IER_CCFIE_B_0x0 = 0;
        /** @brief Enabled (not masked) */
    constexpr std::uint32_t AES_IER_CCFIE_B_0x1 = 1;

    /** @brief Read or write error interrupt enable This bit enables or disables (masks) the AES interrupt generation when RWEIF (read and/or write error flag) is set. */
    using AES_IER_RWEIE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Disabled (masked) (value: 0)
     *          - B_0x1: Enabled (not masked) (value: 1)
     */
        /** @brief Disabled (masked) */
    constexpr std::uint32_t AES_IER_RWEIE_B_0x0 = 0;
        /** @brief Enabled (not masked) */
    constexpr std::uint32_t AES_IER_RWEIE_B_0x1 = 1;

    /** @brief Key error interrupt enable This bit enables or disables (masks) the AES interrupt generation when KEIF (key error flag) is set. */
    using AES_IER_KEIE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 2, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Disabled (masked) (value: 0)
     *          - B_0x1: Enabled (not masked) (value: 1)
     */
        /** @brief Disabled (masked) */
    constexpr std::uint32_t AES_IER_KEIE_B_0x0 = 0;
        /** @brief Enabled (not masked) */
    constexpr std::uint32_t AES_IER_KEIE_B_0x1 = 1;

    /** @brief AES interrupt status register */
    using AES_ISR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x304, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Computation complete flag This flag indicates whether the computation is completed: The flag is set by hardware upon the completion of the computation. It is cleared by software, upon setting the CCF bit of the AES_ICR register. Upon the flag setting, an interrupt is generated if enabled through the CCFIE bit of the AES_IER register. The flag is significant only when the DMAOUTEN bit is 0. It may stay high when DMA_EN is 1. */
    using AES_ISR_CCF = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Not completed (value: 0)
     *          - B_0x1: Completed (value: 1)
     */
        /** @brief Not completed */
    constexpr std::uint32_t AES_ISR_CCF_B_0x0 = 0;
        /** @brief Completed */
    constexpr std::uint32_t AES_ISR_CCF_B_0x1 = 1;

    /** @brief Read or write error interrupt flag This read-only bit is set by hardware when a RDERR or a WRERR error flag is set in the AES_SR register. RWEIF bit is cleared when application sets the corresponding bit of AES_ICR register. An interrupt is generated if the RWEIE bit has been previously set in the AES_IER register. This flags has no meaning when key derivation mode is selected. */
    using AES_ISR_RWEIF = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: No read or write error detected (value: 0)
     *          - B_0x1: Read or write error detected (see AES_SR register for details) (value: 1)
     */
        /** @brief No read or write error detected */
    constexpr std::uint32_t AES_ISR_RWEIF_B_0x0 = 0;
        /** @brief Read or write error detected (see AES_SR register for details) */
    constexpr std::uint32_t AES_ISR_RWEIF_B_0x1 = 1;

    /** @brief Key error interrupt flag This read-only bit is set by hardware when key information failed to load into key registers. Setting the corresponding bit of the AES_ICR register clears the KEIF and generates interrupt if the KEIE bit of the AES_IER register is set. KEIF is triggered upon any of the following errors: AES_KEYRx register write does not respect the correct order. (For KEYSIZE = 0, AES_KEYR0 then AES_KEYR1 then AES_KEYR2 then AES_KEYR3 register, or reverse. For KEYSIZE = 1, AES_KEYR0 then AES_KEYR1 then AES_KEYR2 then AES_KEYR3 then AES_KEYR4 then AES_KEYR5 then AES_KEYR6 then AES_KEYR7, or reverse). KEIF must be cleared by the application software, otherwise KEYVALID cannot be set. */
    using AES_ISR_KEIF = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 2, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: No key error detected (value: 0)
     *          - B_0x1: Key information failed to load into key registers (value: 1)
     */
        /** @brief No key error detected */
    constexpr std::uint32_t AES_ISR_KEIF_B_0x0 = 0;
        /** @brief Key information failed to load into key registers */
    constexpr std::uint32_t AES_ISR_KEIF_B_0x1 = 1;

    /** @brief AES interrupt clear register */
    using AES_ICR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x308, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Computation complete flag clear Setting this bit clears the CCF status bit of the AES_SR and AES_ISR registers. */
    using AES_ICR_CCF = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Read or write error interrupt flag clear Setting this bit clears the RWEIF status bit of the AES_ISR register, and both RDERR and WRERR flags in the AES_SR register. */
    using AES_ICR_RWEIF = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Key error interrupt flag clear Setting this bit clears the KEIF status bit of the AES_ISR register. */
    using AES_ICR_KEIF = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 2, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
}

#endif
