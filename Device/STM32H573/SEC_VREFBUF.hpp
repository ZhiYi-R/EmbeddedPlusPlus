/* Auto-generated file. Do not edit manually. */

#ifndef EMBEDDED_PP_STM32H573_SEC_VREFBUF_HPP
#define EMBEDDED_PP_STM32H573_SEC_VREFBUF_HPP

#include <cstdint>
#include "Core/Common.hpp"
#include "Core/BitField.hpp"
#include "Core/Register.hpp"

/** @brief Voltage reference buffer */
namespace STM32H573::SEC_VREFBUF {

    /** @brief VREFBUF control and status register */
    using VREFBUF_CSR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x0, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode. */
    using VREFBUF_CSR_ENVR = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: Internal voltage reference mode disable (external voltage reference mode). (value: 0)
     *          - B_0x1: Internal voltage reference mode (reference buffer enable or hold mode) enable. (value: 1)
     */
        /** @brief Internal voltage reference mode disable (external voltage reference mode). */
    constexpr std::uint32_t VREFBUF_CSR_ENVR_B_0x0 = 0;
        /** @brief Internal voltage reference mode (reference buffer enable or hold mode) enable. */
    constexpr std::uint32_t VREFBUF_CSR_ENVR_B_0x1 = 1;

    /** @brief High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to for the mode descriptions depending on ENVR bit configuration. */
    using VREFBUF_CSR_HIZ = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: VREF+ pin is internally connected to the voltage reference buffer output. (value: 0)
     *          - B_0x1: VREF+ pin is high impedance. (value: 1)
     */
        /** @brief VREF+ pin is internally connected to the voltage reference buffer output. */
    constexpr std::uint32_t VREFBUF_CSR_HIZ_B_0x0 = 0;
        /** @brief VREF+ pin is high impedance. */
    constexpr std::uint32_t VREFBUF_CSR_HIZ_B_0x1 = 1;

    /** @brief Voltage reference buffer ready */
    using VREFBUF_CSR_VRR = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 3, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @details Possible values:
     *          - B_0x0: the voltage reference buffer output is not ready. (value: 0)
     *          - B_0x1: the voltage reference buffer output reached the requested level. (value: 1)
     */
        /** @brief the voltage reference buffer output is not ready. */
    constexpr std::uint32_t VREFBUF_CSR_VRR_B_0x0 = 0;
        /** @brief the voltage reference buffer output reached the requested level. */
    constexpr std::uint32_t VREFBUF_CSR_VRR_B_0x1 = 1;

    /** @brief Voltage reference scale These bits select the value generated by the voltage reference buffer. VRS = 000: VREFBUF0 voltage selected. VRS = 001: VREFBUF1 voltage selected. VRS = 010: VREFBUF2 voltage selected. VRS = 011: VREFBUF3 voltage selected. Others: Reserved Note: Refer to the product datasheet for each VREFBUFx voltage setting value. The software can program this bitfield only when the VREFBUF is disabled (ENVR=0). */
    using VREFBUF_CSR_VRS = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 4, 3, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief VREFBUF calibration control register */
    using VREFBUF_CCR = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Trimming code The TRIM code is a 6-bit unsigned data (minimum 000000, maximum 111111) that is set and updated according the mechanism described below. Reset: TRIM[5:0] is automatically initialized with the VRS = 0 trimming value stored in the Flash memory during the production test. VRS change: TRIM[5:0] is automatically initialized with the trimming value (corresponding to VRS setting) stored in the Flash memory during the production test. Write in TRIM[5:0]: User can modify the TRIM[5:0] with an arbitrary value. This is permanently disabling the control of the trimming value with VRS (until the device is reset). Note: If the user application performs the trimming, the trimming code must start from 000000 to 111111 in ascending order. */
    using VREFBUF_CCR_TRIM = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 6, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
}

#endif
