/* Auto-generated file. Do not edit manually. */

#ifndef EMBEDDED_PP_STM32U3C5_USBSRAM_HPP
#define EMBEDDED_PP_STM32U3C5_USBSRAM_HPP

#include <cstdint>
#include "Core/Common.hpp"
#include "Core/BitField.hpp"
#include "Core/Register.hpp"

/** @brief USBSRAM Address block */
namespace STM32U3C5::USBSRAM {

    /** @brief Channel/endpoint transmit buffer descriptor 0 */
    using USBSRAM_CHEP_TxRxBD_0 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x0, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel */
    using USBSRAM_CHEP_TxRxBD_0_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEP0R register at the next IN token addressed to it. */
    using USBSRAM_CHEP_TxRxBD_0_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 0 */
    using USBSRAM_CHEP_TxRxBD_0_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x0, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer */
    using USBSRAM_CHEP_TxRxBD_0_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel */
    using USBSRAM_CHEP_TxRxBD_0_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_TxRxBD_0_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_TxRxBD_0_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 0 */
    using USBSRAM_CHEP_RxTxBD_0 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP0R register at the next IN token addressed to it. */
    using USBSRAM_CHEP_RxTxBD_0_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEPnR register at the next IN token addressed to it. */
    using USBSRAM_CHEP_RxTxBD_0_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 0 */
    using USBSRAM_CHEP_RxTxBD_0_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP0R register at the next OUT/SETUP token addressed to it. */
    using USBSRAM_CHEP_RxTxBD_0_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEPnR register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_RxTxBD_0_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_RxTxBD_0_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_RxTxBD_0_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 1 */
    using USBSRAM_CHEP_TxRxBD_1 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x8, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP1R register at the next IN token addressed to it. */
    using USBSRAM_CHEP_TxRxBD_1_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEP1R register at the next IN token addressed to it. */
    using USBSRAM_CHEP_TxRxBD_1_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 1 */
    using USBSRAM_CHEP_TxRxBD_1_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x8, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP1R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_TxRxBD_1_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEP1R register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_TxRxBD_1_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_TxRxBD_1_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_TxRxBD_1_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 1 */
    using USBSRAM_CHEP_RxTxBD_1 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0xC, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP1R register at the next IN token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. */
    using USBSRAM_CHEP_RxTxBD_1_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEPnR register at the next IN token addressed to it. */
    using USBSRAM_CHEP_RxTxBD_1_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 1 */
    using USBSRAM_CHEP_RxTxBD_1_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0xC, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP1R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_RxTxBD_1_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEPnR register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_RxTxBD_1_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_RxTxBD_1_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_RxTxBD_1_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 2 */
    using USBSRAM_CHEP_TxRxBD_2 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP2R register at the next IN token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. */
    using USBSRAM_CHEP_TxRxBD_2_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEP2R register at the next IN token addressed to it. */
    using USBSRAM_CHEP_TxRxBD_2_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 2 */
    using USBSRAM_CHEP_TxRxBD_2_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP2R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_TxRxBD_2_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEP2R register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_TxRxBD_2_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_TxRxBD_2_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_TxRxBD_2_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 2 */
    using USBSRAM_CHEP_RxTxBD_2 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x14, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP2R register at the next IN token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. */
    using USBSRAM_CHEP_RxTxBD_2_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEPnR register at the next IN token addressed to it. */
    using USBSRAM_CHEP_RxTxBD_2_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 2 */
    using USBSRAM_CHEP_RxTxBD_2_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x14, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP2R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_RxTxBD_2_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEPnR register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_RxTxBD_2_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_RxTxBD_2_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_RxTxBD_2_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 3 */
    using USBSRAM_CHEP_TxRxBD_3 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x18, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP3R register at the next IN token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. */
    using USBSRAM_CHEP_TxRxBD_3_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEP3R register at the next IN token addressed to it. */
    using USBSRAM_CHEP_TxRxBD_3_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 3 */
    using USBSRAM_CHEP_TxRxBD_3_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x18, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP3R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_TxRxBD_3_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEP3R register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_TxRxBD_3_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_TxRxBD_3_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_TxRxBD_3_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 3 */
    using USBSRAM_CHEP_RxTxBD_3 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x1C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP3R register at the next IN token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. */
    using USBSRAM_CHEP_RxTxBD_3_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEPnR register at the next IN token addressed to it. */
    using USBSRAM_CHEP_RxTxBD_3_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 3 */
    using USBSRAM_CHEP_RxTxBD_3_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x1C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP3R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_RxTxBD_3_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEPnR register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_RxTxBD_3_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_RxTxBD_3_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_RxTxBD_3_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 4 */
    using USBSRAM_CHEP_TxRxBD_4 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x20, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP4R register at the next IN token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. */
    using USBSRAM_CHEP_TxRxBD_4_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEP4R register at the next IN token addressed to it. */
    using USBSRAM_CHEP_TxRxBD_4_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 4 */
    using USBSRAM_CHEP_TxRxBD_4_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x20, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP4R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_TxRxBD_4_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEP4R register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_TxRxBD_4_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_TxRxBD_4_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_TxRxBD_4_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 4 */
    using USBSRAM_CHEP_RxTxBD_4 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x24, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP4R register at the next IN token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. */
    using USBSRAM_CHEP_RxTxBD_4_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEPnR register at the next IN token addressed to it. */
    using USBSRAM_CHEP_RxTxBD_4_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 4 */
    using USBSRAM_CHEP_RxTxBD_4_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x24, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP4R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_RxTxBD_4_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEPnR register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_RxTxBD_4_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_RxTxBD_4_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_RxTxBD_4_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 5 */
    using USBSRAM_CHEP_TxRxBD_5 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x28, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP5R register at the next IN token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. */
    using USBSRAM_CHEP_TxRxBD_5_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEP5R register at the next IN token addressed to it. */
    using USBSRAM_CHEP_TxRxBD_5_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 5 */
    using USBSRAM_CHEP_TxRxBD_5_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x28, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP5R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_TxRxBD_5_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEP5R register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_TxRxBD_5_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_TxRxBD_5_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_TxRxBD_5_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 5 */
    using USBSRAM_CHEP_RxTxBD_5 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x2C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP5R register at the next IN token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. */
    using USBSRAM_CHEP_RxTxBD_5_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEPnR register at the next IN token addressed to it. */
    using USBSRAM_CHEP_RxTxBD_5_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 5 */
    using USBSRAM_CHEP_RxTxBD_5_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x2C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP5R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_RxTxBD_5_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEPnR register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_RxTxBD_5_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_RxTxBD_5_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_RxTxBD_5_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 6 */
    using USBSRAM_CHEP_TxRxBD_6 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x30, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP6R register at the next IN token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. */
    using USBSRAM_CHEP_TxRxBD_6_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEP6R register at the next IN token addressed to it. */
    using USBSRAM_CHEP_TxRxBD_6_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 6 */
    using USBSRAM_CHEP_TxRxBD_6_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x30, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP6R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_TxRxBD_6_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEP6R register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_TxRxBD_6_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_TxRxBD_6_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_TxRxBD_6_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 6 */
    using USBSRAM_CHEP_RxTxBD_6 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x34, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer containing data to be transmitted by the endpoint/channel associated with the USB_CHEP6R register at the next IN token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. */
    using USBSRAM_CHEP_RxTxBD_6_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEPnR register at the next IN token addressed to it. */
    using USBSRAM_CHEP_RxTxBD_6_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 6 */
    using USBSRAM_CHEP_RxTxBD_6_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x34, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer, which contains the data received by the endpoint/channel associated with the USB_CHEP6R register at the next OUT/SETUP token addressed to it. Bits 1 and 0 must always be written as '00 ' since packet memory is word wide and all packet buffers must be word aligned. Note: This table location is used to store two different values, both required during packet reception. The most significant bits contains the definition of allocated buffer size, to allow buffer overflow detection, while the least significant part of this location is written back by the USB peripheral at the end of reception to give the actual number of received bytes. Due to the restrictions on the number of available bits, buffer size is represented using the number of allocated memory blocks, where block size can be selected to choose the trade-off between fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of allocated buffer is a part of the endpoint/channel descriptor and it is normally defined during the enumeration process according to its maxPacketSize parameter value (see 'Universal Serial Bus Specification '). */
    using USBSRAM_CHEP_RxTxBD_6_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEPnR register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_RxTxBD_6_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_RxTxBD_6_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_RxTxBD_6_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 7 */
    using USBSRAM_CHEP_TxRxBD_7 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x38, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer */
    using USBSRAM_CHEP_TxRxBD_7_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEP7R register at the next IN token addressed to it. */
    using USBSRAM_CHEP_TxRxBD_7_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 7 */
    using USBSRAM_CHEP_TxRxBD_7_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x38, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer */
    using USBSRAM_CHEP_TxRxBD_7_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEP7R register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_TxRxBD_7_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_TxRxBD_7_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_TxRxBD_7_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 7 */
    using USBSRAM_CHEP_RxTxBD_7 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x3C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer */
    using USBSRAM_CHEP_RxTxBD_7_ADDR_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes to be transmitted by the endpoint/channel associated with the USB_CHEPnR register at the next IN token addressed to it. */
    using USBSRAM_CHEP_RxTxBD_7_COUNT_Tx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel/endpoint transmit buffer descriptor 7 */
    using USBSRAM_CHEP_RxTxBD_7_ALTERNATE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x3C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits point to the starting address of the packet buffer */
    using USBSRAM_CHEP_RxTxBD_7_ALTERNATE_ADDR_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits contain the number of bytes received by the endpoint/channel associated with the USB_CHEPnR register during the last OUT/SETUP transaction addressed to it. */
    using USBSRAM_CHEP_RxTxBD_7_ALTERNATE_COUNT_Rx = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief These bits define the number of memory blocks allocated to this packet buffer. The actual amount of allocated memory depends on the BLSIZE value as illustrated in less than xe7 []/>. */
    using USBSRAM_CHEP_RxTxBD_7_ALTERNATE_NUM_BLOCK = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 26, 5, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief This bit selects the size of memory block used to define the allocated buffer area. - If BLSIZE = 0, the memory block is 2-byte large, which is the minimum block allowed in a half-word wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes. - If BLSIZE = 1, the memory block is 32-byte large, which permits to reach the maximum packet length defined by USB specifications. With this block size the allocated buffer size theoretically ranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard specifications. However, the applicable size is limited by the available buffer memory. */
    using USBSRAM_CHEP_RxTxBD_7_ALTERNATE_BLSIZE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 31, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
}

#endif
