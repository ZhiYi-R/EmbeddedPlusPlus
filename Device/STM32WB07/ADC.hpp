/* Auto-generated file. Do not edit manually. */

#ifndef EMBEDDED_PP_STM32WB07_ADC_HPP
#define EMBEDDED_PP_STM32WB07_ADC_HPP

#include <cstdint>
#include "Core/Common.hpp"
#include "Core/BitField.hpp"
#include "Core/Register.hpp"

/** @brief ADC address block description */
namespace STM32WB07::ADC {

    /** @brief VERSION_ID register */
    using VERSION_ID = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x0, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief version of the embedded IP. */
    using VERSION_ID_VERSION_ID = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 8, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC configuration register */
    using CONF = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief possibility to keep the VBIAS_PRECH enabled to deactivate the filter */
    using CONF_VBIAS_PRECH_FORCE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 20, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief select the input sampling method */
    using CONF_ADC_CONT_1V2 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 19, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief invert bit to bit the ADC data output when a 								differential */
    using CONF_BIT_INVERT_DIFF = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 18, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief invert bit to bit the ADC data output when a single */
    using CONF_BIT_INVERT_SN = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 17, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief decimation overrun configuration */
    using CONF_OVR_DF_CFG = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Down Sampler overrun configuration */
    using CONF_OVR_DS_CFG = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 15, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief enable DMA mode for Decimation Filter data path */
    using CONF_DMA_DF_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 14, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief enable DMA mode for Down Sampler data path */
    using CONF_DMA_DS_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 13, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief conversion rate of ADC */
    using CONF_SAMPLE_RATE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 11, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC mode selection (= data path selection) */
    using CONF_OP_MODE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 7, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief synchronize the ADC start conversion with a pulse 								generated by the */
    using CONF_SMPS_SYNCHRO_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 6, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief number of conversions in a regular sequence */
    using CONF_SEQ_LEN = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 2, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief enable the sequence mode (active by default) */
    using CONF_SEQUENCE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief regular sequence runs continuously when ADC mode is enabled */
    using CONF_CONT = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC control register */
    using CTRL = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x8, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief enable the LDO associated to the ADC block */
    using CTRL_ADC_LDO_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 5, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief select the functional or the test mode of the ADC */
    using CTRL_TEST_MODE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 4, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief enable the digital audio mode (the data path uses 								the decimation filter) */
    using CTRL_DIG_AUD_MODE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 3, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief stop the on-going OP_MODE (ADC mode, Analog audio mode, Full */
    using CTRL_STOP_OP_MOD = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 2, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief generate a start pulse to initiate an ADC conversion */
    using CTRL_START_CON = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC_ON_OFF: – 0: power off the ADC – 1: power on the ADC */
    using CTRL_ADC_ON_OFF = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Occasionnal mode control register */
    using OCM_CTRL = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0xC, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief start occasional conversion in analog audio and full 								modes */
    using OCM_CTRL_OCM_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief select the occasional conversion source */
    using OCM_CTRL_OCM_SRC = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief PGA configuration register */
    using PGA_CONF = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x10, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief set the microphone bias voltage */
    using PGA_CONF_PGA_BIAS = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 4, 3, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief from 6 to 30 dB */
    using PGA_CONF_PGA_GAIN = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC switch control for Input Selection */
    using SWITCH = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x14, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief input voltage for VINP[3] */
    using SWITCH_SE_VIN_7 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 14, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief input voltage for VINP[2] */
    using SWITCH_SE_VIN_6 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 12, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief input voltage for VINP[1] */
    using SWITCH_SE_VIN_5 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 10, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief input voltage for VINP[0] */
    using SWITCH_SE_VIN_4 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 8, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief input voltage for VINM[3] / VINP[3]-VINM[3] */
    using SWITCH_SE_VIN_3 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 6, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief input voltage for VINM[2] / VINP[2]-VINM[2] */
    using SWITCH_SE_VIN_2 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 4, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief input voltage for VINM[1] / VINP[1]-VINM[1] */
    using SWITCH_SE_VIN_1 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 2, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief input voltage for VINM[0] / VINP[0]-VINM[0] */
    using SWITCH_SE_VIN_0 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Decimation filter configuration register */
    using DF_CONF = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x18, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief half dynamic enable. */
    using DF_CONF_DF_HALF_D_EN = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 17, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief high pass filter enable. */
    using DF_CONF_DF_HPF_EN = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief left/right channel selection on digital microphone */
    using DF_CONF_DF_MICROL_RN = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 15, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief select the PDM clock rate. */
    using DF_CONF_PDM_RATE = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 11, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief select signed/unsigned format for data output */
    using DF_CONF_DF_O_S2U = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 10, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief select signed/unsigned format for input */
    using DF_CONF_DF_I_U2S = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 9, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief 1.2 fractional interpolator enable */
    using DF_CONF_DF_ITP1P2 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 8, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief CIC filter decimator half factor */
    using DF_CONF_DF_CIC_DHF = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 7, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief DF_CIC_DEC_FACTOR field */
    using DF_CONF_DF_CIC_DEC_FACTOR = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 7, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Downsampler configuration register */
    using DS_CONF = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x1C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief program the Down Sampler width of data output (DSDTATA) */
    using DS_CONF_DS_WIDTH = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 3, 3, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief program the Down Sampler ratio (N factor) */
    using DS_CONF_DS_RATIO = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 3, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC regular sequence configuration register 1 */
    using SEQ_1 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x20, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 8th conversion of the sequence. */
    using SEQ_1_SEQ7 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 28, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 7th conversion of the sequence. */
    using SEQ_1_SEQ6 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 24, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 6th conversion of the sequence. */
    using SEQ_1_SEQ5 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 20, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 5th conversion of the sequence. */
    using SEQ_1_SEQ4 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 4th conversion of the sequence. */
    using SEQ_1_SEQ3 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 12, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 3rd conversion of the sequence. */
    using SEQ_1_SEQ2 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 8, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for second conversion of the sequence. */
    using SEQ_1_SEQ1 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 4, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for first conversion of the sequence */
    using SEQ_1_SEQ0 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC regular sequence configuration register 2 */
    using SEQ_2 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x24, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 16th conversion of the sequence. */
    using SEQ_2_SEQ15 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 28, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 15th conversion of the sequence. */
    using SEQ_2_SEQ14 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 24, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 14th conversion of the sequence. */
    using SEQ_2_SEQ13 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 20, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 13th conversion of the sequence. */
    using SEQ_2_SEQ12 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 12th conversion of the sequence. */
    using SEQ_2_SEQ11 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 12, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 11th conversion of the sequence. */
    using SEQ_2_SEQ10 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 8, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 10th conversion of the sequence. */
    using SEQ_2_SEQ9 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 4, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief channel number code for 9th conversion of the sequence */
    using SEQ_2_SEQ8 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 4, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC Gain and offset correction values register 1 */
    using COMP_1 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x28, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief first calibration point: signed offset	compensation[6:0] */
    using COMP_1_OFFSET1 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 12, 7, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief first calibration point: gain AUXADC_GAIN_1V2[11:0] */
    using COMP_1_GAIN1 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 12, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC Gain and offset correction values register 2 */
    using COMP_2 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x2C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief second calibration point: signed offset compensation[6:0] */
    using COMP_2_OFFSET2 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 12, 7, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief second calibration point: gain AUXADC_GAIN_1V2[11:0] */
    using COMP_2_GAIN2 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 12, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC Gain and offset correction values register 3 */
    using COMP_3 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x30, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief third calibration point: signed offset compensation[6:0] */
    using COMP_3_OFFSET3 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 12, 7, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief third calibration point: gain AUXADC_GAIN_1V2[11:0] */
    using COMP_3_GAIN3 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 12, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC Gain and offset correction values register 4 */
    using COMP_4 = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x34, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief fourth calibration point: signed offset compensation[6:0] */
    using COMP_4_OFFSET4 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 12, 7, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief fourth calibration point: gain AUXADC_GAIN_1V2[11:0] */
    using COMP_4_GAIN4 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 12, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief ADC Gain and Offset selection values register */
    using COMP_SEL = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x38, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief gain / offset used in ADC differential mode with Vinput range = 3.6V */
    using COMP_SEL_GAIN_OFFSET8 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief gain / offset used in ADC single positive mode with Vinput range = 3.6V */
    using COMP_SEL_GAIN_OFFSET7 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 14, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief gain / offset used in ADC single negative mode with Vinput range = 3.6V */
    using COMP_SEL_GAIN_OFFSET6 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 12, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief gain / offset used in ADC differential mode with Vinput range = 2.4V */
    using COMP_SEL_GAIN_OFFSET5 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 10, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief gain / offset used in ADC single positive mode with Vinput range = 2.4V */
    using COMP_SEL_GAIN_OFFSET4 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 8, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief gain / offset used in ADC single negative mode with Vinput range = 2.4V */
    using COMP_SEL_GAIN_OFFSET3 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 6, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief gain / offset used in ADC differential mode with Vinput range = 1.2V */
    using COMP_SEL_GAIN_OFFSET2 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 4, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief gain / offset used in ADC single positive mode with Vinput range = 1.2V */
    using COMP_SEL_GAIN_OFFSET1 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 2, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief gain / offset used in ADC single negative mode with Vinput range = 1.2V */
    using COMP_SEL_GAIN_OFFSET0 = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 2, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief High/low limits for event monitoring a channel register */
    using WD_TH = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x3C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief analog watchdog high level threshold. */
    using WD_TH_WD_HT = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 12, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief analog watchdog low level threshold. */
    using WD_TH_WD_LT = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 12, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Channel selection for event monitoring register */
    using WD_CONF = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x40, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief analog watchdog channel selection to define which input channel(s) need to be guarded by the watchdog. */
    using WD_CONF_AWD_CHX = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Downsampler Data output register */
    using DS_DATAOUT = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x44, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief contain the converted data at the output of the Down Sampler */
    using DS_DATAOUT_DS_DATA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Decimation filter Data output register */
    using DF_DATAOUT = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x48, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief contain the converted data at the output of the 								decimation filter. */
    using DF_DATAOUT_DF_DATA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 16, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Interrupt Status register */
    using IRQ_STATUS = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x4C, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief set to indicate the decimation filter is saturated. */
    using IRQ_STATUS_DF_OVRFL_IRQ = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 7, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief set to indicate a decimation filter overrun (a data is lost) */
    using IRQ_STATUS_OVR_DF_IRQ = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 6, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief set to indicate a Down Sampler overrun (at least one data is lost) */
    using IRQ_STATUS_OVR_DS_IRQ = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 5, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief set when an analog watchdog event occurs */
    using IRQ_STATUS_AWD_IRQ = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 4, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief set when a sequence of conversion is completed */
    using IRQ_STATUS_EOS_IRQ = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 3, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief set when the decimation filter conversion is completed */
    using IRQ_STATUS_EODF_IRQ = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 2, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief set when the Down Sampler conversion is completed. */
    using IRQ_STATUS_EODS_IRQ = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief (Used in test mode only): set when the ADC conversion is completed. */
    using IRQ_STATUS_EOC_IRQ = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Enable/disable Interrupts */
    using IRQ_ENABLE = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x50, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief decimation filter saturation interrupt enable */
    using IRQ_ENABLE_DF_OVRFL_IRQ_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 7, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief decimation filter overrun interrupt enable */
    using IRQ_ENABLE_OVR_DF_IRQ_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 6, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Down Sampler overrun interrupt enable */
    using IRQ_ENABLE_OVR_DS_IRQ_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 5, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief analog watchdog interrupt enable */
    using IRQ_ENABLE_AWD_IRQ_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 4, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief End of regular sequence interrupt enable */
    using IRQ_ENABLE_EOS_IRQ_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 3, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief End of conversion interrupt enable for the decimation filter output */
    using IRQ_ENABLE_EODF_IRQ_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 2, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief End of conversion interrupt enable for the Down Sampler output */
    using IRQ_ENABLE_EODS_IRQ_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 1, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief (Used in test mode only): End of ADC conversion interrupt enable */
    using IRQ_ENABLE_EOC_IRQ_ENA = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Time to add after an LDO Enable or ADC Enable to let the HW to be stable before using it */
    using TIMER_CONF = ::EmbeddedPP::LowLevel::Register<std::uint32_t, 0x54, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief Select the time step PD_STEP for the VBIAS_PRECH_DELAY timer */
    using TIMER_CONF_PRECH_DELAY_SEL = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 16, 1, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief define the duration of a waiting time starting at rising edge of PGA_EN signal and corresponding to the VBIAS precharge duration */
    using TIMER_CONF_VBIAS_PRECH_DELAY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 8, 8, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
    /** @brief define the duration of a waiting time to be inserted between the ADC_LDO enable and the ADC ON to let time to the LDO to stabilize before starting a conversion. */
    using TIMER_CONF_ADC_LDO_DELAY = ::EmbeddedPP::LowLevel::BitField<std::uint32_t, 0, 8, ::EmbeddedPP::LowLevel::Accessibility::ReadWrite>;
}

#endif
